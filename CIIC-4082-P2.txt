#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     0x01C00                 ; Start of RAM        ORG     1C00


        RSEG    CSTACK                    ; pre-declaration of segment
        RSEG    CODE                      ; place program in 'CODE' segment

options  dw     option, log, reads
opIndex  dw     0  

batteryH  DB    0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0, 0xF0  ;High Bytes for battery 
batteryL  DB    0x10, 0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0  ;Low Bytes for battery

; This is an extension of the previous subroutine 
init:   MOV     #SFE(CSTACK), SP          ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        mov.w   #0xFFFF,&LCDCPCTL0        ;Enable LCD segments 0-21; 26-43
        mov.w   #0xFC3F,&LCDCPCTL1
        mov.w   #0x0FFF,&LCDCPCTL2


        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT

        bis.b   #00000110b, &P1REN      ; P1.1 & 2  Resistor enabled as pullup
        bis.b   #00000110b, &P1OUT      ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #00000110b, &P1IE       ; Enable interrupt at P1.1 & 2
        bis.b   #00000110b, &P1IES      ; Set interrupt on high-to-low 
                                        ; transition of P1.1 & 2

        MOV.B   #0,R4
        
                
SetupP1:
        bic.b   #0xFF,&P1SEL0            ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1            ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings
        mov.w   #0x041e,&LCDCCTL0
        mov.w   #0x0208,&LCDCVCTL
        mov.w   #0x8000,LCDCCPCTL
        mov.w   #2,&LCDCMEMCTL
        
        ;Turn LCD on
        Bis.w   #1,&LCDCCTL0
        
        mov.w   #0,opIndex
        clr     R5
        bic.b   #00000110b, &P1IFG      ; To erase a flag raised before
        
        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

        call    #option

        ;bis     #LPM0,SR                ; Enter Low Power Mode 0
        ;NOP

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
       
cOption:
      call      #option
      jmp       finI
      
cLog:
      call      #log
      jmp       finI
      
cReads:
      call      #reads
      jmp       finI
       
option:
      call      #clear  
      mov.b     #0xFC,&0xA29                    ;O

      mov.b     #0xCF,&0xA25                    ;P

      mov.b     #0x80,&0xA23                    ;T
      mov.b     #0x50,&0xA24
      
      mov.b     #0x90,&0xA32                    ;I
      mov.b     #0x50,&0xA33
      
      mov.b     #0xFC,&0xA2E                    ;O

      mov.b     #0x6C,&0xA27                    ;N
      mov.b     #0x82,&0xA28   
      
      ret
      
log:
      call      #clear
      mov.b     #0x1C,&0xA29                    ;L

      mov.b     #0xFC,&0xA25                    ;O

      mov.b     #0xBD,&0xA23                    ;G

      ret
      
reads:
      call      #clear
      mov.b     #0xCF,&0xA29                    ;R
      mov.b     #0x02,&0xA2A

      mov.b     #0x9F,&0xA25                    ;E

      mov.b     #0xEF,&0xA23                    ;A
      
      mov.b     #0xF0,&0xA32                    ;D
      mov.b     #0x50,&0xA33
      ret
   
;Objetivo: Prender las barras de la bateria en el LCD
;Precondiciones: El registro R4 contiene la posicion del LCD a ser encendido (bateria)
;Postcondiciones: 
;Autor: 
;Fecha: 
loadBattery:
        CMP     #6, R4
        jeq     resetBattery
        INC     R4
        mov.b   batteryH(R4), &0x0a31
        mov.b   batteryL(R4), &0x0a2D
        jmp     finI

;Objetivo: Reiniciar las barras de la bateria en el LCD
;Precondiciones: El registro R4 contiene la posicion del LCD a ser encendido (bateria)
;Postcondiciones: 
;Autor: 
;Fecha: 
resetBattery:
        mov     #0, R4
        mov.b   batteryH(R4), &0x0a31
        mov.b   batteryL(R4), &0x0a2D
        jmp     finI
 
nextOp:
        incd    R5
        cmp     #6,R5
        jz      returnOp
        call    options(R5)
        jmp     finI
        
clear:
        MOV.W   #2,&LCDCMEMCTL
        Bis.w   #1,&LCDCCTL0
        ret
        
;Objetivo: 
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
returnOp:
        mov.b   #0,R5
        call    #clear
        call    options(R5)
        jmp     finI
        
return:
        ret
       
fin:
        JMP $
        NOP     
        
PORT1_ISR
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        JZ      rightButton
        
        JMP     leftButton
        
;Objetivo: Llamar subrutina indicada al presionar S1
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
leftButton:
        bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check
        jmp     loadBattery
        jmp     finI

;Objetivo: Llamar subrutina indicada al presionar S2
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
rightButton:
       bic.b   #00000100b,&P1IFG        ; Clear interrupt flag and check 
       jmp     nextOp
       
       jmp      finI        
        
     
finI:   ;incd    R5               ; Increment the pushes counter

        reti                            ; Return from interrupt
        END
