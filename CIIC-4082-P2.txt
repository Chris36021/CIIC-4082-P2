#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module
        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    checkBPMFinished        ; set vector for 'checkBPMFinished' routine

        ORG     0FFDEh
        DC16    pressHeart              ; set vector for 'pressHeart' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
        DC16    pressCounter            ; Interrupts generated by Port 1 will
                                         ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x01C00                 ; Start of RAM        ORG     1C00
batteryCounter  DW 0                    ; Battery 30s counter
heartCounter    DW 0

        RSEG    CSTACK                    ; pre-declaration of segment
        RSEG    CODE                      ; place program in 'CODE' segment

options  dw     option, reads, log
opIndex  dw     0  

;Digits           0    1    2   3    4    5    6    7    8    9
digitH  db      0xFC,0x60,0xDB,0xF3,0x67,0xB7,0xBF,0xE0,0xFF,0xF7
digitL  db      0x28,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

batteryH  DB    0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0, 0xF0  ;High Bytes for battery 
batteryL  DB    0x00, 0x00, 0x20, 0x20, 0x60, 0x60, 0xE0, 0xE0  ;Low Bytes for battery

;Displays
disp            dw      0xA29,0xA25,0xA23,0xA29,0xA25,0xA23
Final           dw      0xA29,0xA25,0xA23,0xA32,0xA2E,0xA27

level           dw      0
pressed         dw      0
count           dw      0
multiplier      dw      0



init:   MOV     #SFE(CSTACK), SP          ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        mov.w   #0xFFFF,&LCDCPCTL0        ;Enable LCD segments 0-21; 26-43
        mov.w   #0xFC3F,&LCDCPCTL1
        mov.w   #0x0FFF,&LCDCPCTL2
 
        mov     #0, heartCounter
        mov     #0, batteryCounter
        mov     #0, level
        mov     #0, pressed
        mov     #0, count
        mov     #0, multiplier

        bis.b   #00000110b, &P1REN      ; P1.1 & 2  Resistor enabled as pullup
        bis.b   #00000110b, &P1OUT      ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #00000110b, &P1IE       ; Enable interrupt at P1.1 & 2
        bis.b   #00000110b, &P1IES      ; Set interrupt on high-to-low 
                                        ; transition of P1.1 & 2

        MOV.B   #0,R4
        
                
SetupP1:
        bic.b   #0xFF,&P1SEL0            ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1            ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activate
                                        ; previously configured port settings
        mov.w   #0x041e,&LCDCCTL0
        mov.w   #0x0208,&LCDCVCTL
        mov.w   #0x8000,LCDCCPCTL
        mov.w   #2,&LCDCMEMCTL
        
        ;Turn LCD on
        Bis.w   #1,&LCDCCTL0
        
        
        ; Timer related heart
        mov     #CCIE, &TA1CCTL0        
        mov     #TASSEL_2+MC_0+ID_3, &TA1CTL  ;Set timer according to next table
        nop
        mov     #12500, &TA1CCR0 
        
        ; Timer related to battery
        mov     #CCIE, &TA0CCTL0        ; Enable TACCR0 interrupt
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL  ;Set timer according to next table
        nop
        mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0
        
        mov.w   #0,opIndex
        clr     R5                      ;Instruction array index
        clr     R6                      ;Button press counter
        clr     R8                      ;Flag to indicate what will be done
        clr     R9                      ;BPM Result 
        mov.W   #65535,R7		   ;Value to be used for waitingTime subroutine
        mov.w   #0x19FF, R11		   ;Address containing the latest recorded BPM
        
        mov     #0,R14		   ;Índice de arreglo a utilizar para hacerle display a la batería

        bic.b   #00000110b, &P1IFG      ;To erase a flag raised before
        
        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	            ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

        call    #option

        bis     #LPM0,SR                ; Enter Low Power Mode 0
        NOP

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)

;Objetivo: Presentar en pantalla la palabra option.
;Precondiciones: Habilitar el LCD 
;Postcondiciones: Enseña la palabra option en el LCD
;Autor: Hermes Colón
;Fecha: 03/24/2021         
option:
      call      #clear  
      mov.b     #0xFC,&0xA29                    ;O

      mov.b     #0xCF,&0xA25                    ;P

      mov.b     #0x80,&0xA23                    ;T
      mov.b     #0x50,&0xA24
      
      mov.b     #0x90,&0xA32                    ;I
      mov.b     #0x50,&0xA33
      
      mov.b     #0xFC,&0xA2E                    ;O

      mov.b     #0x6C,&0xA27                    ;N
      mov.b     #0x82,&0xA28   
      
      ret

;Objetivo: Presentar en pantalla la palabra log.
;Precondiciones: Habilitar el LCD 
;Postcondiciones: Enseña la palabra log en el LCD
;Autor: Hermes Colón
;Fecha: 03/24/2021   
      
log:
      call      #clear
      mov.b     #0x1C,&0xA29                    ;L

      mov.b     #0xFC,&0xA25                    ;O

      mov.b     #0xBD,&0xA23                    ;G

      ret

;Objetivo: Presentar en pantalla la palabra read.
;Precondiciones: Habilitar el LCD 
;Postcondiciones: Enseña la palabra read en el LCD
;Autor: Hermes Colón
;Fecha: 03/24/2021  
      
reads:
      call      #clear
      mov.b     #0xCF,&0xA29                    ;R
      mov.b     #0x02,&0xA2A

      mov.b     #0x9F,&0xA25                    ;E

      mov.b     #0xEF,&0xA23                    ;A
      
      mov.b     #0xF0,&0xA32                    ;D
      mov.b     #0x50,&0xA33
      ret

;Objetivo: Presentar en pantalla la palabra save.
;Precondiciones: Habilitar el LCD 
;Postcondiciones: Enseña la palabra save en el LCD
;Autor: Gabriela Cardona
;Fecha: 04/14/2021  
save:       

      call      #clear
      mov       #13,level
       
      mov.b     #10110111B,&0x0A29             ;S

      mov.b     #0xEF,&0xA25                   ;A

      mov.b     #00001100B,&0x0A23
      mov.b     #00101000B,&0x0A24             ;V
                
      mov.b     #0x9F,&0x0A32                  ;E

      reti
;Objetivo: Presentar en pantalla la palabra BPM.
;Precondiciones: Habilitar el LCD 
;Postcondiciones: Enseña las letras BPM en el LCD
;Autor: Christopher Castillo
;Fecha: 04/17/2021   
BPM:    

      call      #clearNums  
      mov.b     #0xF1,&0xA32                    ;B
      mov.b     #0x50,&0xA33     

      mov.b     #0xCF,&0xA2E                    ;P

      mov.b     #0x6C,&0xA27                    ;M
      mov.b     #0xA0,&0xA28

      ret
;Objetivo: Presenta en la pantalla el reloj en el estado 12
;Precondiciones: Habilitar el LCD 
;Postcondiciones: Enciende el reloj en la posición 0x0A22. 
;Autor: Gabriela Cardona
;Fecha: 04/14/2021      
watch: 
      mov         #12, level
      mov.b       #00001000B,&0x0A22    ; watch sign
      reti 

;Objetivo: Determinar si el cálculo actual necesita ser dividido
;Precondiciones: R9 contiene el resultado actual, batteryCounter contiene la cuenta de cuántas del total 
; de índices que se ha iterado por el  array de la batería
;Postcondiciones: R9 contiene 0 si el número debe ser dividido o el resultado actual si no hay que ejecutar mas calculos
;Autor: María Cordero
;Fecha: 04/22/2021
checkDivisionNeeded:
        MOV     #0,R9
        cmp     #21, batteryCounter     ; BPM at 18s
        jeq     divide10
        cmp     #28, batteryCounter     ; BPM at 24s
        jeq     divide2
        MOV     R6,R9                              ; Store result in R9
        JMP     pushAndCallDisplay
        RET
   
; This is an extension of the previous subroutine            
divide10:
        SUB.W   #10,R6                          ;Subtract denominator from numerator
        JN      setUpDivDisplay                 ;If it's negative, end the division operation
        INC     R9                              ;Increase result
        JMP     divide10                         ;Loop again

; This is an extension of the previous subroutine 
divide2:
        SUB.W   #2,R6                           ;Subtract denominator from numerator
        JN      setUpDivDisplay                 ;If it's negative, end the division operation
        INC     R9                              ;Increase result
        JMP     divide2   

; This is an extension of the previous subroutine 
setUpDivDisplay:
        MOV     R9,R6
        JMP     pushAndCallDisplay
               
;Objetivo: Multiplicar el valor en pressed al resultado con el valor contenido en la variable multiplier
;Precondiciones: pressed contiene el número a ser multiplicado, R6 contiene el resultado
; count actúa como counter de multiplier, multiplier contiene el número al que se multiplicará
;Postcondiciones: R6 tendrá el resultado
;Autor: María Cordero
;Fecha: 04/17/2021
calculateBPM:
        Add     pressed,R6                         ; Add temp value to R6 repeated 10 times
        INC     count                      
        CMP     multiplier, count                  ; If count reaches multiplier, stop loop
        JNE     calculateBPM                       ; loop again
        MOV     #0,count
        call    #checkDivisionNeeded   
   
;Objetivo: Determinar si han transcurrido 30 segundos del comienzo de leer los BPM
;Precondiciones: batteryCounter contiene la cuenta de cuántas del total de índices que se ha iterado por el array de la batería
;Postcondiciones: La subrutina brincará a la próxima subrutina correspondiente dependiendo de el valor en batteryCounter
;Autor: María Cordero
;Fecha: 04/17/2021
checkBPMFinished:
        cmp     #35, batteryCounter
        jne     loadBattery  
        jeq     endReadStage
        reti    
        
;Objetivo: Prender las barras de la batería en el LCD
;Precondiciones: El registro R14 contiene la posición del LCD a ser encendido
;Postcondiciones: El byte correspondiente a la próxima barra será encendido
; si llega al final del arreglo brinca a subrutina resetBattery
;Autor: María Cordero
;Fecha: 04/06/2021
loadBattery:
        inc     batteryCounter
        CMP     #6, R14
        jeq     resetBattery
        INC     R14
        mov.b   batteryH(R14), &0x0a31
        mov.b   batteryL(R14), &0x0a2D
        jmp     finI

;Objetivo: Esta subrutina actualiza el nivel actual y lleva a la pantalla los brackets de la batería a la pantalla LCD.  
;Precondiciones: El nivel actual es el nivel denominado como ‘0’ y se habrá presionado el botón S1 en 
;la opción de READ 
;Postcondiciones: El nivel actual será el nivel denominado como ‘10’ y e la pantalla se 
;presentarán los “brackets” de la batería.  
;Autor: Christopher Castillo
;Fecha: 03/17/2021             
loadInitBattery:
        call    #clear
        mov     #10,level
        mov.b   batteryH, &0x0a31
        mov.b   batteryL, &0x0a2D
        jmp     finI

;Objetivo: Reiniciar las barras de la batería en el LCD
;Precondiciones: El registro R14 contiene la posición del LCD a ser encendido
;Postcondiciones: El byte correspondiente a la primera barra será encendido
;Autor: María Cordero
;Fecha: 04/06/2021
resetBattery:
        mov     #0, R14
        mov.b   batteryH(R14), &0x0a31
        mov.b   batteryL(R14), &0x0a2D
        jmp     bpmSwitchStatement  
        
;Objetivo: Simular un switch statement para determinar el cálculo correcto de BPM
;Precondiciones: batteryCounter contiene la cuenta de cuántas del total de índices que se ha iterado por el array de la batería
;Postcondiciones: Se brincará a la subrutina correspondiente a los segundos que han transcurrido
;Autor: María Cordero
;Fecha: 04/17/2021
bpmSwitchStatement:
        mov     batteryCounter,R14
        mov     #0,R14
        cmp     #7, batteryCounter      ; BPM at 6s
        jeq     setUp6sBPM
        cmp     #14, batteryCounter     ; BPM at 12s
        jeq     setUp12sBPM
        cmp     #21, batteryCounter     ; BPM at 18s
        jeq     setUp18sBPM
        cmp     #28, batteryCounter     ; BPM at 24s
        jeq     setUp24sBPM
        cmp     #35, batteryCounter     ; BPM at 30s
        jeq     setUp30sBPM
        RETI
       
; This is an extension of the previous subroutine 
setUp6sBPM:
        mov     #10, multiplier
        jmp     calculateBPM
; This is an extension of the previous subroutine 
setUp12sBPM:
        mov     #5, multiplier
        jmp     calculateBPM
; This is an extension of the previous subroutine 
setUp18sBPM:
        mov     #33, multiplier
        jmp     calculateBPM
; This is an extension of the previous subroutine 
setUp24sBPM:
        mov     #5, multiplier
        jmp     calculateBPM
; This is an extension of the previous subroutine 
setUp30sBPM:
        mov     #2, multiplier
        jmp     calculateBPM

;Objetivo: Reiniciar las variables utilizadas durante el nivel de calculación de BPM
;Precondiciones: R14, batteryCounter, pressed contienen los resultados del pasado nivel de BPM
;Postcondiciones: R14, batteryCounter, pressed contienen 0 para ser utilizadas nuevamente en la próxima lectura de BPM
;Autor: María Cordero
;Fecha:04/15/2021
clearReadStageRegisters:
        MOV     #0, R14
        MOV     #0, batteryCounter
        MOV     #0, pressed
        RET

;Objetivo: Esta subrutina cambia la opción actual que se está mostrando en la pantalla. 
;Precondiciones: En la pantalla se encuentra la palabra READ o LOG, el estado actual es ‘0’.
;Postcondiciones: En la pantalla se mostrará la palabra READ o LOG, el estado actual sigue siendo ‘0’. 
;Autor: Christopher Castillo
;Fecha: 03/05/2021
nextOp:
        incd    R5
        cmp     #6,R5
        jz      returnOp
        call    options(R5)
        jmp     finI
        
clear:
        MOV.W   #2,&LCDCMEMCTL
        Bis.w   #1,&LCDCCTL0
        ret

;Objetivo: Esta subrutina elimina de la pantalla solamente los caracteres alfanuméricos que están siendo mostrados.
;Precondiciones: En la pantalla habrán uno o más caracteres alfanuméricos siendo mostrados.
;Postcondiciones: En la pantalla no habrá ningún carácter alfanumérico siendo mostrado.
;Autor: Christopher Castillo
;Fecha: 03/20/2021        
clearNums:
        mov.b     #0,&0xA29                    ;Alph 1
        mov.b     #0,&0xA2A
        
        mov.b     #0,&0xA25                    ;Alph 2
        mov.b     #0,&0xA26    
        
        mov.b     #0,&0xA23                    ;Alph 3
        mov.b     #0,&0xA24
        
        mov.b     #0,&0xA32                    ;Alph 4
        mov.b     #0,&0xA33
        
        mov.b     #0,&0xA2E                    ;Alph 5
        mov.b     #0,&0xA2F
        
        mov.b     #0,&0xA27                    ;Alph 6
        mov.b     #0,&0xA28        
        ret
;Objetivo: Implementar un delay para mejorar implementación de botones.
;Precondiciones: R7 tiene un valor de #65535
;Postcondiciones: R7 tendrá un valor de 0
;Autor: Hermes Colon
;Fecha: 02/28/2021      
waitingTime:
        dec.w   R7
        cmp.w   #0,R7    
        jnz     waitingTime
        mov.w   #65535,R7
        ret
        
;Objetivo: Esta subrutina implementa el funcionamiento cíclico en las opciones que se muestran en la pantalla
;en el estado ‘0’. 
;Precondiciones: En la pantalla se encuentra la palabra READ o LOG, el estado actual es ‘0’.
;Postcondiciones: En la pantalla se mostrará la palabra READ o LOG, el estado actual sigue siendo ‘0’. 
;Autor: Christopher Castillo
;Fecha: 03/05/2021
returnOp:
        mov.b   #2,R5
        call    #clear
        call    options(R5)
        jmp     finI
       
;Objetivo: Determinar qué botón (S1 o S2) fue presionado
;Precondiciones: Se detectó una interrupción en el puerto 1
;Postcondiciones: La subrutina correspondiente al botón presionado fue ejecutada
;Autor: María Cordero
;Fecha: 04/06/2021
PORT1_ISR
        call    #waitingTime

 
 
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        JZ      rightButton
        
        JMP     leftButton

        
;Objetivo: Llamar subrutina correspondiente al nivel actual al presionar S1
;Precondiciones: La variable level contiene el número predeterminado de un nivel
;Postcondiciones: La subrutina atada al nivel actual es ejecutada
;Autor: Maria, Hermes, Christopher, Gabriela
;Fecha: 04/15/2021
leftButton:
        bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check
        
        cmp     #0,level        ; Select between read / log
        jeq     selectReadLog
        cmp     #10,level       ; Only battery bars stage
        jeq     loadReadStage
        cmp     #11,level       ; battery / heart / BPM stage
        jeq     pressCounter
        cmp     #13,level       ; "Save" level
        JEQ     saveResults
        cmp     #21,level       ; Loading last 3 logs
        JEQ     loadLog
             
        jmp     finI
      
;Objetivo: Llamar subrutina correspondiente al nivel actual al presionar S2
;Precondiciones: La variable level contiene el número predeterminado de un nivel
;Postcondiciones: La subrutina atada al nivel actual es ejecutada
;Autor: Maria, Hermes, Christopher, Gabriela
;Fecha: 04/15/2021
rightButton:
       bic.b   #00000100b,&P1IFG        ; Clear interrupt flag and check 

       cmp      #0,level                ; Move through operations
       jeq      nextOp
       cmp      #12,level               ; watch level
       jeq      save
       cmp      #13,level               ; "Save" level
       jeq      backToOption
       
       jmp      finI 

;Objetivo: Presentar de manera cíclicamente la palabra LOG y READ
;Precondiciones: En la pantalla se encuentra la palabra READ o LOG, el estado actual es ‘0’.
;Postcondiciones:Si el usuario presiona S1 entrara al estado deseado ya sea LOG o READ.
;Autor: Hermes Colón,Gabriela Cardona
;Fecha: 04/18/2021       
selectReadLog:
        cmp.b   #2,R5                   ; LOG
        JEQ     loadInitBattery
        cmp.b   #4,R5                   ; READ
        JEQ     loadLog
        reti

;Objetivo: Llamar la subrutina necesaria para que se presente el próximo número del “LOG” en la pantalla.
;Precondiciones: El nivel actual es ‘0’ ó ‘21’.
;Postcondiciones: Se llamará una subrutina que lleva un valor de BPM a la pantalla o se volverá al menú principal.
;Autor: Christopher Castillo
;Fecha: 04/08/2021            
loadLog:
        mov     #21,level
        cmp     #0x19FF,R11
        jz      displayFirst
        cmp     #0x19FC,R11
        jz      displaySecond
        cmp     #0x19FA,R11
        jz      displayThird
        cmp     #0x19F8,R11
        jz      backToOption
        reti

;Objetivo: Comenzar el timer TA0CTL (correspondiente a la batería) y activar el próximo nivel
;Precondiciones: level contiene valor del nivel previo (10), el timer TA0CTL está parado
;Postcondiciones: level contiene valor del nivel actual (11), el timer TA0CTL está corriendo
;Autor: María Cordero
;Fecha: 04/16/2021
loadReadStage:
        mov     #11,level       ; battery / heart / BPM stage
        mov     #TASSEL_2+MC_3+ID_3, &TA0CTL  ;Start timer
        call    #clearNums
        jmp     loadBattery

;Objetivo: Comenzar el timer TA0CTL (correspondiente a la batería) 
;Precondiciones: Los timer TA0CTL y TA1CTL están corriendo
;Postcondiciones: Los timer TA0CTL y TA1CTL están parado
;Autor: María Cordero
;Fecha: 04/16/2021
endReadStage:
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL  ;Stop timer
        mov     #TASSEL_2+MC_0+ID_3, &TA1CTL  ;stop timer heart
        mov     #0, &0x0a31
        mov     #0, &0x0a2D
        
        call    #clearReadStageRegisters
        JMP     watch
        reti    

;Objetivo: Guardar los resultados en las direcciones del “LOG’ con el resultado más reciente en primer lugar.
;Precondiciones: El usuario presionó el botón S1 mientras la palabra “READ” se mostraba en la pantalla.
;Postcondiciones: El último valor medido se habrá guardado en la primera posición del “LOG”.
;Autor: Christopher Castillo
;Fecha: 04/16/2021   
saveResults:
        mov.w   &0x19FC, &0x19FA
        mov.w   &0x19FF, &0x19FC
        mov.w   R9, &0x19FF
        clr     R9
        jmp     backToOption
        
optionSelected:
        mov.w   #1,R8

;Objetivo: Mover la información necesaria a los registros pertinentes para que se pueda mostrar en la pantalla el BPM más reciente.
;Precondiciones: El “level” actual es ‘21’.
;Postcondiciones: El registro R11 tendrá la dirección del segundo número a mostrar y R6 tendrá el valor del BPM más reciente.
;Autor: Christopher Castillo
;Fecha: 04/17/2021           
displayFirst:
        mov.w   &0x19FF,R6
        mov.w   #0x19FC,R11
        jmp     pushAndCallDisplay
    
;Objetivo: Mover la información necesaria a los registros pertinentes para que se pueda mostrar en la pantalla el segundo BPM más ;reciente.
;Precondiciones: El “level” actual es ‘21’.
;Postcondiciones: El registro R11 tendrá la dirección del tercer número a mostrar y R6 tendrá el valor del segundo BPM más reciente.
;Autor: Christopher Castillo
;Fecha: 04/17/2021     
displaySecond:
        mov.w   &0x19FC,R6
        mov.w   #0x19FA,R11
        jmp     pushAndCallDisplay
  
;Objetivo: Mover la información necesaria a los registros pertinentes para que se pueda mostrar en la pantalla el tercer BPM más ;reciente.
;Precondiciones: El “level” actual es ‘21’.
;Postcondiciones: El registro R11 tendrá una dirección indicadora de que ya los tres BPMs disponibles se han mostrado y R6 tendrá el ;valor del tercer BPM más reciente.
;Autor: Christopher Castillo
;Fecha: 04/17/2021       
displayThird:
        mov.w   &0x19FA,R6
        mov.w   #0x19F8,R11
        jmp     pushAndCallDisplay

;Objetivo: Esta subrutina reinicializa todos los valores pertinentes a sus estados iniciales y lleva el usuario al menú principal.
;Precondiciones: El “level” actual es 13 ó 21.
;Postcondiciones: R5 y level tendrán un valor de 0, en la pantalla estará la palabra “OPTION”. R11 tendrá la dirección 
;del último valor que se guardó en el LOG.
;Autor: Christopher Castillo
;Fecha: 04/05/2021         
backToOption:
        mov     #0,level
        mov.w   #0x19FF,R11
        clr     R5
        call    options(R5)
        jmp     finI

;Objetivo:Esta subrutina se  utiliza para saber si el corazón está prendido o apagado.
;Precondiciones:Se utiliza un espacio en memoria inicialmente con el valor 0.
;Postcondiciones:Si el corazón está apagado lo enciende y si está encendido lo apaga.
;Autor: Hermes Colón
;Fecha: 04/18/2021     
pressCounter:
        mov.b   #0x04,&0xA22
        mov     #TASSEL_2+MC_1+ID_3, &TA1CTL  ;Start timer heart
        inc     pressed
        jmp     finI

;Objetivo:Enciende el corazón 0.2 segundos luego de presionar S1.
;Precondiciones:Presionar el botón S1 en el estado 11.
;Postcondiciones:Enciende el corazón y se apaga luego de 0.2 segundos.
;Autor: Hermes Colón
;Fecha: 04/18/2021     
pressHeart:
        cmp     #12,level
        jeq     finI
        cmp     #1,heartCounter        
        jz      stopHeart		;está encendido el corazón
        mov.b   #0x04,&0xA22
        inc     heartCounter
        jmp     finI

;Objetivo:Apaga  el corazón luego de  0.2 segundos luego de presionar S1.
;Precondiciones:Presionar el botón S1 en el estado 11.
;Postcondiciones:Apaga el corazón luego de 0.2 segundos. 
;Autor: Hermes Colón
;Fecha: 04/18/2021     
stopHeart:
        mov.b   #0x00,&0xA22
        mov     #TASSEL_2+MC_0+ID_3, &TA1CTL  ;Start timer heart
        mov     #0,heartCounter
        jmp     finI  
  
;Objetivo:Las próximas subrutinas se utilizaron para usar el stack con los remainders del 
;resultados poder determinar los dígitos individualmente y presentarlos en la pantalla.
;Precondiciones:Utiliza R7 que  contiene resultado
;Postcondiciones:Stack con dígitos por separado del resultado
;Autor: Hermes Colón
;Fecha: 03/14/2021 
pushAndCallDisplay:
        call    #BPM
        clr     R15                        ;Leading 0 flag
        mov.w   R6,R8
        PUSH.W  #0x00CD                    ;Push inicial para saber fin de mostrarD
        cmp     #100,R6
        jn      lead0
        JMP     displayResult

;Objetivo: Indicar que el número que se va a llevar al display tiene al menos un 0 a la izquierda.
;Precondiciones: R15 tiene un valor de 0
;Postcondiciones: R15 tiene un valor de 1
;Autor: Christopher Castillo
;Fecha: 04/17/2021         
lead0:
        inc     R15
  
; This is an extension of the previous subroutine         
displayResult:
        clr     R12                    ;Result
        clr     R13                    ;Remainder
; This is an extension of the previous subroutine        
displayDivide:
        MOV.W   R6,R13
        SUB.W   #10,R6                    ;Subtract denominator from numerator
        JN      nextRemainder             ;If it's negative, end the division operation
        INC     R12                       ;Increase result
        JMP     displayDivide             ;Loop again

; This is an extension of the previous subroutine 
nextRemainder:
        mov     R12,R6
        push.w  R13                       ;Remainder se le hace push en stack
        cmp     #0,R12
        jnz     displayResult
        mov.w   #Final,R4                ;Contiene todas las localizaciones del display
        jz      checkFlag

;Objetivo: Verifica si el número a llevar a la pantalla necesita un 0 a la izquierda
;Precondiciones: R15 tiene un valor de 0 ó 1
;Postcondiciones: De necesitar algún 0 a la izquierda, se prosigue a la subrutina de pushSecond. De lo contrario, Se sigue
; se prosigue a mostrar el número en la pantalla.
;Autor: Christopher Castillo
;Fecha: 04/17/2021          
checkFlag:
        CMP     #1,R15
        JEQ     pushSecond
        JNE     mostrarD

;Objetivo: Llevar la cantidad de 0’s a la izquierda que necesita el número al Stack.
;Precondiciones: R15 tiene un valor de 1
;Postcondiciones: El Stack tendrá al menos un cero en su tope.
;Autor: Christopher Castillo
;Fecha: 03/17/2021          
pushSecond:
        MOV.w   #0,R15                   ;Turn off flag
        CMP     #100,R8	     
        JGE     mostrarD
        CMP     #10,R8
        JGE     pushCeroOnce              
        push.w  #0
        push.w  #0
        JMP     mostrarD
 
; This is an extension of the previous subroutine 
pushCeroOnce:
        push.w  #0
        JMP     mostrarD
        
;Objetivo: Se utiliza el stack para presentar en pantalla el resultado al encontrar CDCD daba por terminado el programa
;Precondiciones: Stack con dígitos por separado del resultado
;Postcondiciones: Enseñaba el resultado en la pantalla
;Autor: Hermes Colón
;Fecha: 03/13/2021     
mostrarD:
        mov.w   @R4,R13
        Pop.w   R10                     ;Dígitos saliendo del stack     
        cmp.b   #0x00CD,R10             ;Al encontrar este valor en el stack se  termina el programa
        JEQ     selectReturn

        mov.b   digitH(R10),0(R13)      ;Se muestran en el display los dígito de manera secuencial
        mov.b   digitL(R10),1(R13)
        incd.w  R4
        jmp     mostrarD     
        
;Objetivo: Determinar en qué nivel se encuentra el programa
;Precondiciones: El nivel 21 requiere ejecutar un RETI
;Postcondiciones: La subrutina con el return correspondiente al nivel actual fue ejecutada
;Autor: María Cordero
;Fecha: 04/17/2021
selectReturn:
        CMP     #21,level
        JEQ     finI
        JNE     return     
 
return:
        ret
       
fin:
        JMP $
        NOP  
  
finI:                                 
        reti                            ; Return from interrupt
        END
