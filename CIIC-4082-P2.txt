#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module
        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
        DC16    pressCounter            ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x01C00                 ; Start of RAM        ORG     1C00
intsCounter     DW 0                    ; TIMER_A0 interrupts counter
batteryCounter  DW 0                    ; Battery 30s counter

        RSEG    CSTACK                    ; pre-declaration of segment
        RSEG    CODE                      ; place program in 'CODE' segment

options  dw     option, reads, log
opIndex  dw     0  

;Digits           0    1    2   3    4    5    6    7    8    9
digitH  db      0xFC,0x60,0xDB,0xF3,0x67,0xB7,0xBF,0xE0,0xFF,0xF7
digitL  db      0x28,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

batteryH  DB    0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0, 0xF0  ;High Bytes for battery 
batteryL  DB    0x10, 0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0  ;Low Bytes for battery

;Displays
disp    dw      0xA29,0xA25,0xA23,0xA29,0xA25,0xA23
Final   dw      0xA29,0xA25,0xA23,0xA32,0xA2E,0xA27

level   dw      0
pressed dw      0
count   dw      0
multiplier      dw      0


; This is an extension of the previous subroutine 
init:   MOV     #SFE(CSTACK), SP          ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        mov.w   #0xFFFF,&LCDCPCTL0        ;Enable LCD segments 0-21; 26-43
        mov.w   #0xFC3F,&LCDCPCTL1
        mov.w   #0x0FFF,&LCDCPCTL2

        mov     #0, intsCounter         ; Clear intsCounter
        mov     #0, batteryCounter
        mov     #0, level
        mov     #0, pressed
        mov     #1, count
        mov     #0, multiplier
        
        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT

        bis.b   #00000110b, &P1REN      ; P1.1 & 2  Resistor enabled as pullup
        bis.b   #00000110b, &P1OUT      ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #00000110b, &P1IE       ; Enable interrupt at P1.1 & 2
        bis.b   #00000110b, &P1IES      ; Set interrupt on high-to-low 
                                        ; transition of P1.1 & 2

        MOV.B   #0,R4
        
                
SetupP1:
        bic.b   #0xFF,&P1SEL0            ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1            ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings
        mov.w   #0x041e,&LCDCCTL0
        mov.w   #0x0208,&LCDCVCTL
        mov.w   #0x8000,LCDCCPCTL
        mov.w   #2,&LCDCMEMCTL
        
        ;Turn LCD on
        Bis.w   #1,&LCDCCTL0
        
        ; Timer related
        mov     #CCIE, &TA0CCTL0        ; Enable TACCR0 interrupt
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        mov     #25000, &TA0CCR0        ; Set the timer capture compare register 0
        
        mov.w   #0,opIndex
        clr     R5                      ;Instruction array index
        clr     R6                      ;Button press counter
        clr     R8                      ;Flag to indicate what will be done
        clr     R9                      ;BPM Result 
        mov.W   #65535,R7
        mov.w   #0x19FF, R11
        
        mov     #0,R14
        
        mov.w   #4,&0x19FF
        mov.w   #69,&0x19FC 
        mov.w   #420,&0x19FA  
        
        bic.b   #00000110b, &P1IFG      ;To erase a flag raised before
        
        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

        call    #option

        bis     #LPM0,SR                ; Enter Low Power Mode 0
        NOP

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
       
cOption:
      call      #option
      jmp       finI
      
cLog:
      call      #log
      jmp       finI
      
cReads:
      call      #reads
      jmp       finI
       
option:
      call      #clear  
      mov.b     #0xFC,&0xA29                    ;O

      mov.b     #0xCF,&0xA25                    ;P

      mov.b     #0x80,&0xA23                    ;T
      mov.b     #0x50,&0xA24
      
      mov.b     #0x90,&0xA32                    ;I
      mov.b     #0x50,&0xA33
      
      mov.b     #0xFC,&0xA2E                    ;O

      mov.b     #0x6C,&0xA27                    ;N
      mov.b     #0x82,&0xA28   
      
      ret
      
log:
      call      #clear
      mov.b     #0x1C,&0xA29                    ;L

      mov.b     #0xFC,&0xA25                    ;O

      mov.b     #0xBD,&0xA23                    ;G

      ret
      
reads:
      call      #clear
      mov.b     #0xCF,&0xA29                    ;R
      mov.b     #0x02,&0xA2A

      mov.b     #0x9F,&0xA25                    ;E

      mov.b     #0xEF,&0xA23                    ;A
      
      mov.b     #0xF0,&0xA32                    ;D
      mov.b     #0x50,&0xA33
      ret
 
save:              ;SAVE   ;GABRIELA

      call      #clear
      mov       #13,level
       
      mov.b     #10110111B,&0x0A29             ;S

      mov.b     #0xEF,&0xA25                   ;A

      mov.b     #00001100B,&0x0A23
      mov.b     #00101000B,&0x0A24             ;V
                
      mov.b     #0x9F,&0x0A32                  ;E

      reti
      
showresultBPM: 
      jmp       pushAndCallDisplay  
      ret
   
BPM:    
      call      #clear  
      mov.b     #0xF1,&0xA32                    ;B
      mov.b     #0x50,&0xA33     

      mov.b     #0xCF,&0xA2E                    ;P

      mov.b     #0x6C,&0xA27                    ;M
      mov.b     #0xA0,&0xA28

      ret
   
watch:                                            ;GABRIELA
      call        #clear
      mov         #12, level
      mov.b       #00001000B,&0x0A22   ; watch sign
      reti 
   
TIMER_A0_ISR:
      
      xor.b   #0x04,&0xA22
      
      cmp     #3,intsCounter
      
      jeq     checkBPMFinished
      jne     noBattery

      jmp     finI   
   
   
noBattery:
        inc     intsCounter
        reti   

checkBPMFinished:
        cmp     #35, batteryCounter
        jne     loadBattery  
        jeq     endReadStage
        reti    
        


;Objetivo: Prender las barras de la bateria en el LCD
;Precondiciones: El registro R14 contiene la posicion del LCD a ser encendido (bateria)
;Postcondiciones: 
;Autor: 
;Fecha:
loadBattery:
        inc     batteryCounter
        mov     #0,intsCounter
        CMP     #6, R14
        jeq     resetBattery
        INC     R14
        mov.b   batteryH(R14), &0x0a31
        mov.b   batteryL(R14), &0x0a2D
        jmp     finI

;Objetivo: Reiniciar las barras de la bateria en el LCD
;Precondiciones: El registro R14 contiene la posicion del LCD a ser encendido (bateria)
;Postcondiciones: 
;Autor: 
;Fecha: 
resetBattery:
        mov     #0, R14
        mov.b   batteryH(R14), &0x0a31
        mov.b   batteryL(R14), &0x0a2D
        jmp     bpmSwitchStatement  
        
bpmSwitchStatement:
        cmp     #7, batteryCounter      ; BPM at 6s
        jeq     setUp6sBPM
        cmp     #14, batteryCounter     ; BPM at 12s
        jeq     setUp12sBPM
        cmp     #21, batteryCounter     ; BPM at 18s
        jeq     setUp18sBPM
        cmp     #28, batteryCounter     ; BPM at 24s
        jeq     setUp24sBPM
        cmp     #35, batteryCounter     ; BPM at 30s
        jeq     setUp30sBPM
        RET
        
setUp6sBPM:
        mov     #10, multiplier
        jmp     calculateBPM
setUp12sBPM:
        mov     #5, multiplier
        jmp     calculateBPM
setUp18sBPM:
        mov     #3, multiplier
        jmp     calculateBPM
setUp24sBPM:
        mov     #2, multiplier
        jmp     calculateBPM
setUp30sBPM:
        mov     #2, multiplier
        jmp     calculateBPM

clearReadStageRegisters:
        MOV     #0, R14
        MOV     #0, batteryCounter
        MOV     #0, pressed
        RET
        

;Objetivo: Multiplicar el valor en pressed al resultado 10 veces
;Precondiciones: pressed contiene el número a ser multiplicado, R6 contiene el resultado, count actúa como counter de 1-10
;Postcondiciones: R6 tendrá el resultado con cero a la derecha
;Autor: María Cordero
;Fecha: 
calculateBPM:
        Add     pressed,R6                   ; Add temp value to R6 repeated 10 times
        INC     count                      
        CMP     multiplier, count                  ; If R4 reaches 10, stop loop
        JNE     calculateBPM
        MOV     #1,count
        MOV     R6,R9
        call    #showresultBPM
        RET

nextOp:
        incd    R5
        cmp     #6,R5
        jz      returnOp
        call    options(R5)
        jmp     finI
        
clear:
        MOV.W   #2,&LCDCMEMCTL
        Bis.w   #1,&LCDCCTL0
        ret
        
waitingTime:
        dec.w   R7
        cmp.w   #0,R7    
        jnz     waitingTime
        mov.w   #65535,R7
        ret
        
;Objetivo: 
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
returnOp:
        mov.b   #2,R5
        call    #clear
        call    options(R5)
        jmp     finI
        
return:
        ret
       
fin:
        JMP $
        NOP     
        
PORT1_ISR
        call    #waitingTime

 
 
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        JZ      rightButton
        
        JMP     leftButton

        
;Objetivo: Llamar subrutina indicada al presionar S1
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
leftButton:
        bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check
        
        cmp     #0,level        ; Select between read / log
        jeq     selectReadLog
        cmp     #11,level       ; battery / heart / BPM stage
        jeq     pressCounter
        cmp     #13,level       ; "Save" level
        JEQ     saveResults
        cmp     #21,level       ; Loading last 3 logs
        JEQ     loadLog
             
        jmp     finI
      
;Objetivo: Llamar subrutina indicada al presionar S2
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
rightButton:
       bic.b   #00000100b,&P1IFG        ; Clear interrupt flag and check 

       cmp      #0,level                ; Move through operations
       jeq      nextOp
       cmp      #12,level               ; watch level
       jeq      save
       cmp      #13,level               ; "Save" level
       jeq      backToOption
       
       jmp      finI 
      
selectReadLog:
        cmp.b   #2,R5                   ; LOG
        JEQ     loadReadStage
        cmp.b   #4,R5                   ; READ
        JEQ     loadLog
        reti
           
loadLog:
        mov     #21,level
        cmp     #0x19FF,R11
        jz      displayFirst
        cmp     #0x19FC,R11
        jz      displaySecond
        cmp     #0x19FA,R11
        jz      displayThird
        cmp     #0x19F8,R11
        jz      backToOption
        reti

loadReadStage:
        mov     #11,level       ; battery / heart / BPM stage
        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Start timer
        call    #clear
        jmp     loadBattery

endReadStage:
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL  ;Stop timer
        call    #clear
        call    #clearReadStageRegisters
        JMP     watch
        reti    


saveResults:
        mov.w   &0x19FC, &0x19FA
         mov.w   &0x19FF, &0x19FC
        mov.w   R9, &0x19FF
        clr     R9
        jmp     backToOption
        
optionSelected:
        mov.w   #1,R8
        
displayFirst:
        mov.w   &0x19FF,R6
        mov.w   #0x19FC,R11
        jmp     pushAndCallDisplay
        
displaySecond:
        mov.w   &0x19FC,R6
        mov.w   #0x19FA,R11
        jmp     pushAndCallDisplay
        
displayThird:
        mov.w   &0x19FA,R6
        mov.w   #0x19F8,R11
        jmp     pushAndCallDisplay
        
backToOption:
        mov     #0,level
        mov.w   #0x19FF,R11
        clr     R5
        call    options(R5)
        jmp     finI

pressCounter:
        inc     pressed
        jmp     finI
  
;Objetivo:Las proximas subrutinas se utilizaron para usar el stack con los remainders del 
;resultados poder determinar los dígitos individualmente y presentarlos en la pantalla.
;Precondiciones:Utiliza R7 que  contiene resultado
;Postcondiciones:Stack con dígitos por separado del resultado
;Autor: Hermes Colón
;Fecha: 03/14/2021 
pushAndCallDisplay:
        call    #BPM
        clr     R15                        ;Leading 0 flag
        mov.w   R6,R8
        PUSH.W  #0x00CD                    ;Push inicial para saber fin de mostrarD
        cmp     #100,R6
        jn      lead0
        JMP     displayResult
        
lead0:
        inc     R15
  
; This is an extension of the previous subroutine         
displayResult:
        clr     R12                    ;Result
        clr     R13                    ;Remainder
; This is an extension of the previous subroutine        
displayDivide:
        MOV.W   R6,R13
        SUB.W   #10,R6                    ;Subtract denominator from numerator
        JN      nextRemainder             ;If it's negative, end the division operation
        INC     R12                       ;Increase result
        JMP     displayDivide             ;Loop again
; This is an extension of the previous subroutine 
nextRemainder:
        mov     R12,R6
        push.w  R13                       ;Remainder se le hace push en stack
        cmp     #0,R12
        jnz     displayResult
        mov.w   #Final,R4                ;Contiene todas las localizaciones del display
        jz      checkFlag
        
checkFlag:
        CMP     #1,R15
        JEQ     pushSecond
        JNE     mostrarD
        
pushSecond:
        MOV.w   #0,R15                   ;Turn off flag
        CMP     #100,R8	     
        JGE     mostrarD
        CMP     #10,R8
        JGE     pushCeroOnce              
        push.w  #0
        push.w  #0
        JMP     mostrarD
 
; This is an extension of the previous subroutine 
pushCeroOnce:
        push.w  #0
        JMP     mostrarD
        
;Objetivo: Se utiliza el stack para presentar en pantalla el resultado al encontrar CDCD daba por terminado el programa
;Precondiciones: Stack con dígitos por separado del resultado
;Postcondiciones: Enseñaba el resultado en la pantalla
;Autor: Hermes Colón
;Fecha: 03/13/2021     
mostrarD:
        mov.w   @R4,R13
        Pop.w   R10                     ;Dígitos saliendo del stack     
        cmp.b   #0x00CD,R10             ;Al encontrar este valor en el stack se  termina el programa
        JEQ     finI

        mov.b   digitH(R10),0(R13)      ;Se muestran en el display los dígito de manera secuencial
        mov.b   digitL(R10),1(R13)
        incd.w  R4
        jmp     mostrarD

  
     
finI:   ;incd    R5               ; Increment the pushes counter
        reti                            ; Return from interrupt
        END
