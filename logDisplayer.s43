#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
        DC16    pressCounter            ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x01C00                 ; Start of RAM        ORG     1C00


        RSEG    CSTACK                    ; pre-declaration of segment
        RSEG    CODE                      ; place program in 'CODE' segment

;Digits           0    1    2   3    4    5    6    7    8    9
digitH  db      0xFC,0x60,0xDB,0xF3,0x67,0xB7,0xBF,0xE0,0xFF,0xF7
digitL  db      0x28,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

;Displays
disp    dw      0xA29,0xA25,0xA23,0xA29,0xA25,0xA23
Final   dw      0xA29,0xA25,0xA23,0xA32,0xA2E,0xA27

options  dw     option, log, reads

; This is an extension of the previous subroutine 
init:   MOV     #SFE(CSTACK), SP          ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        mov.w   #0xFFFF,&LCDCPCTL0        ;Enable LCD segments 0-21; 26-43
        mov.w   #0xFC3F,&LCDCPCTL1
        mov.w   #0x0FFF,&LCDCPCTL2

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT

        bis.b   #06h, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #06h, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1
        bis.b   #06h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1  
                                        
SetupP1:
        bic.b   #0xFF,&P1SEL0            ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1            ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings
        mov.w   #0x041e,&LCDCCTL0
        mov.w   #0x0208,&LCDCVCTL
        mov.w   #0x8000,LCDCCPCTL
        mov.w   #2,&LCDCMEMCTL
        
        ;Turn LCD on
        Bis.w   #1,&LCDCCTL0
        
        ;mov.w   #0,opIndex
        ;clr     R5                      ;Instruction array index
        mov.w   #0,R5
        clr     R6                      ;Button press counter
        mov.w   #65535,R7               ;Registered used for the delay
        clr     R8                      ;Option selected flag
        clr     R9                      ;Level indicator
        clr     R10                     ;Index for displaying results
        mov.w   #0x19FF,R11             ;Index for result addresses
        
        mov.w   #4,&0x19FF
        mov.w   #69,&0x19FC 
        mov.w   #420,&0x19FA      
        bic.b   #00000110b, &P1IFG      ;To erase a flag raised before
        
        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

        call    #log

        bis     #LPM0,SR                ; Enter Low Power Mode 0
        NOP

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
       
cOption:
      call      #option
      jmp       finI
      
cLog:
      call      #log
      jmp       finI
      
cReads:
      call      #reads
      jmp       finI
       
option:
      call      #clear  
      mov.b     #0xFC,&0xA29                    ;O

      mov.b     #0xCF,&0xA25                    ;P

      mov.b     #0x80,&0xA23                    ;T
      mov.b     #0x50,&0xA24
      
      mov.b     #0x90,&0xA32                    ;I
      mov.b     #0x50,&0xA33
      
      mov.b     #0xFC,&0xA2E                    ;O

      mov.b     #0x6C,&0xA27                    ;N
      mov.b     #0x82,&0xA28   
      
      ret
      
log:
      call      #clear
      mov.b     #0x1C,&0xA29                    ;L

      mov.b     #0xFC,&0xA25                    ;O

      mov.b     #0xBD,&0xA23                    ;G

      ret
      
reads:
      call      #clear
      mov.b     #0xCF,&0xA29                    ;R
      mov.b     #0x02,&0xA2A

      mov.b     #0x9F,&0xA25                    ;E

      mov.b     #0xEF,&0xA23                    ;A
      
      mov.b     #0xF0,&0xA32                    ;D
      mov.b     #0x50,&0xA33
      ret
      
nextOp:
        incd    R5
        cmp     #6,R5
        jz      returnOp
        call    options(R5)
        jmp     finI
        
clear:
        MOV.W   #2,&LCDCMEMCTL
        Bis.w   #1,&LCDCCTL0
        ret
        
buttonCount:
        inc     R6
        bic.b   #00000110b, &P1IFG
        jmp     finI
        
waitingTime:
        dec.w   R7
        cmp.w   #0,R7    
        jnz     waitingTime
        mov.b   &P1IN,R4
        mov.w   #65535,R7
        ret
        
BPM:    
        call      #clear  
        mov.b     #0xF1,&0xA32                    ;B
        mov.b     #0x50,&0xA33     

        mov.b     #0xCF,&0xA2E                    ;P
  
        mov.b     #0x6C,&0xA27                    ;M
        mov.b     #0xA0,&0xA28

        ret
        
;Objetivo: 
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
returnOp:
        mov.b   #2,R5
        call    #clear
        call    options(R5)
        jmp     finI
        
return:
        ret
      
fin:
        JMP $
        NOP     
        
PORT1_ISR
        call    #waitingTime
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        JZ      rightButton
        
        JMP     leftButton

        
;Objetivo: Llamar subrutina indicada al presionar S1
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
leftButton:
        bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check
        ;cmp     #0,R8
        ;jz      optionSelected
        ;cmp     #2,R5

        ;call    #BPM
        cmp     #0x19FF,R11
        jz      displayFirst
        cmp     #0x19FC,R11
        jz      displaySecond
        cmp     #0x19FA,R11
        jz      displayThird
        cmp     #0x19F8,R11
        jz      backToOption

        ;jmp     loadBattery
        ;jmp     buttonCount
        
        jmp     finI


;Objetivo: Llamar subrutina indicada al presionar S2
;Precondiciones: 
;Postcondiciones: 
;Autor: 
;Fecha: 
rightButton:
       bic.b    #00000100b,&P1IFG        ; Clear interrupt flag and check 
       ;jmp      saveResults
       ;jmp     nextOp
       
       jmp      finI     

saveResults:
        mov.w   &0x19FC, &0x19FA
        mov.w   &0x19FF, &0x19FC
        mov.w   R6, &0x19FF
        clr     R6
        jmp     finI
        
optionSelected:
        mov.w   #1,R8
        mov.w   #1,R9
        
displayFirst:
        mov.w   &0x19FF,R6
        mov.w   #0x19FC,R11
        jmp     pushAndCallDisplay
        
displaySecond:
        mov.w   &0x19FC,R6
        mov.w   #0x19FA,R11
        jmp     pushAndCallDisplay
        
displayThird:
        mov.w   &0x19FA,R6
        mov.w   #0x19F8,R11
        jmp     pushAndCallDisplay
        
backToOption:
        mov.w   #0x19FF,R11
        clr     R5
        call    options(R5)
        jmp     finI

pressCounter:
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.2
                                        ; that corresponds to push button S1
                                        
        jz      finI                     ; if no interrupt from push button
        
        bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check 
        
        inc     R6
        ;jmp     buttonCount

        jmp     finI                     ; go to end of ISR

;Objetivo:Las proximas subrutinas se utilizaron para usar el stack con los remainders del 
;resultados poder determinar los dígitos individualmente y presentarlos en la pantalla.
;Precondiciones:Utiliza R7 que  contiene resultado
;Postcondiciones:Stack con dígitos por separado del resultado
;Autor: Hermes Colón
;Fecha: 03/14/2021 
pushAndCallDisplay:
        call    #BPM
        clr     R15                        ;Leading 0 flag
        mov.w   R6,R7
        PUSH.W  #0x00CD                    ;Push inicial para saber fin de mostrarD
        cmp     #100,R6
        jn      lead0
        JMP     displayResult
        
lead0:
        inc     R15
  
; This is an extension of the previous subroutine         
displayResult:
        clr     R12                    ;Result
        clr     R13                    ;Remainder
; This is an extension of the previous subroutine        
displayDivide:
        MOV.W   R6,R13
        SUB.W   #10,R6                    ;Subtract denominator from numerator
        JN      nextRemainder             ;If it's negative, end the division operation
        INC     R12                       ;Increase result
        JMP     displayDivide             ;Loop again
; This is an extension of the previous subroutine 
nextRemainder:
        mov     R12,R6
        push.w  R13                       ;Remainder se le hace push en stack
        cmp     #0,R12
        jnz     displayResult
        mov.w   #Final,R4                ;Contiene todas las localizaciones del display
        jz      checkFlag
        
checkFlag:
        CMP     #1,R15
        JEQ     pushSecond
        JNE     mostrarD
        
pushSecond:
        MOV.w   #0,R15                   ;Turn off flag
        CMP     #100,R7	     
        JGE     mostrarD
        CMP     #10,R7
        JGE     pushCeroOnce              
        push.w  #0
        push.w  #0
        JMP     mostrarD
 
; This is an extension of the previous subroutine 
pushCeroOnce:
        push.w  #0
        JMP     mostrarD
        
;Objetivo: Se utiliza el stack para presentar en pantalla el resultado al encontrar CDCD daba por terminado el programa
;Precondiciones: Stack con dígitos por separado del resultado
;Postcondiciones: Enseñaba el resultado en la pantalla
;Autor: Hermes Colón
;Fecha: 03/13/2021     
mostrarD:
        mov.w   @R4,R13
        Pop.w   R10                     ;Dígitos saliendo del stack     
        cmp.b   #0x00CD,R10             ;Al encontrar este valor en el stack se  termina el programa
        JEQ     finI

        mov.b   digitH(R10),0(R13)      ;Se muestran en el display los dígito de manera secuencial
        mov.b   digitL(R10),1(R13)
        incd.w  R4
        jmp     mostrarD
        
finI:
        reti                            ; Return from interrupt
        END